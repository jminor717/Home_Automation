substitutions:
  device_name: erv-ctrl
  eth_cs: GPIO9
  eth_clk: GPIO10
  eth_miso: GPIO11
  eth_mosi: GPIO12
  eth_int: GPIO13
  eth_rst: GPIO14

  scl_pin: GPIO20
  sda_pin: GPIO19

  erv_in_l_pin: GPIO21
  erv_out_l_pin: GPIO38


external_components:
  - source:
      type: local
      path: ..\..\my_components # path relative to Devices folder

esphome:
  name: $device_name
  platformio_options:
    board_build.flash_mode: dio

esp32:
  board: esp32-s3-devkitc-1
  variant: esp32s3
  flash_size: 8MB
  framework:
    type: esp-idf
    sdkconfig_options:
      CONFIG_ESPTOOLPY_FLASHSIZE_8MB: y

preferences:
  # the default of 1min is far too short--flash chip is rated
  # for approx 100k writes.
  flash_write_interval: "48h"

api:
  # password: ""
ota:
  platform: esphome
  password: ""

logger:
  level: INFO

ethernet:
  type: W5500
  clk_pin: $eth_clk
  mosi_pin: $eth_mosi
  miso_pin: $eth_miso
  cs_pin: $eth_cs
  interrupt_pin: $eth_int
  reset_pin: $eth_rst

time:
  - platform: homeassistant

button:
  - platform: restart
    name: "$device_name Restart"

text_sensor:
  - platform: version
    name: "$device_name Version"


i2c:
  - id: bus_a
    sda: $sda_pin
    scl: $scl_pin
    scan: true

globals:
  - id: filter_queue
    type: std::deque<float>
    restore_value: no
  - id: filter_queue_depth
    type: int
    restore_value: no
    initial_value: '120'
  - id: send_every
    type: int
    restore_value: no
    initial_value: '120'
  - id: last_sent
    type: int
    restore_value: no
    initial_value: '60'
  - id: outlier_threshold
    type: float
    restore_value: no
    initial_value: '0.03'
  - id: amount_to_send_after_outlier
    type: int
    restore_value: no
    initial_value: '20' # after an outlier is detected, we send the next 5 seconds of data
  - id: needs_sent_after_outlier
    type: int
    restore_value: no
    initial_value: '0'

# 0.005715
sensor:
  - { platform: uptime, id: uptime_seconds, update_interval: 1min }
  - { platform: template, id: uptime_days, name: "$device_name uptime", update_interval: 1min, 
      device_class: duration, entity_category: "diagnostic", unit_of_measurement: "d", accuracy_decimals: 2,
      lambda: !lambda "return id(uptime_seconds).state / 86'400;"}
  - platform: sdp3x
    update_interval: 10ms
    name: "Pressure Delta"
    id: pressure_dif
    i2c_id: bus_a
    address: 0x25
    # unit_of_measurement: "Pa"
    filters:
      - sliding_window_moving_average:
          window_size: 50
          send_every: 25
      # send to lambda filter 4 times per second lambda sends once every 30 seconds
      # lambda will average over the last 30 seconds
      # if the value is an outlier to the running average, it will send the next 20 values in order to capture transient events
      - lambda: |-
          float sum = 0;
          size_t valid_count = 0;
          // find running average to check for outliers
          for (auto v : id(filter_queue)) {
            if (!std::isnan(v)) {
              sum += v;
              valid_count++;
            }
          }
          float average = NAN;
          if (valid_count) {
            average = sum / valid_count;
          } else {
            // if no values in queue, just return the current value and add to queue
            id(filter_queue).push_back(x);
            return x;
          }

          id(filter_queue).push_back(x);
          // if the current value is an outlier, we will send the next 20 values
          if (std::abs(x - average) > id(outlier_threshold)) {
            ESP_LOGVV("filt", "outL: %f", x);
            id(needs_sent_after_outlier) = id(amount_to_send_after_outlier);
            id(last_sent) = 0;
            return x;
          }

          if (id(needs_sent_after_outlier) > 0) {
            id(needs_sent_after_outlier)--;
            ESP_LOGVV("filt", "outL sent: %f", x);
            return x;
          }

          // if we have enough values in the queue, pop the oldest one
          if (id(filter_queue).size() >= id(filter_queue_depth)) {
            id(filter_queue).pop_front();
          }
          // send the average every 30 seconds, this average doesn't include the current X but this should be good enough
          if (id(last_sent) >= id(send_every)) {
            id(last_sent) = 0;
            ESP_LOGVV("filt", "AVEe: %f", average);
            return average;
          } else {
            id(last_sent)++;
          }
          return {};


fan:
  - platform: speed
    output: erv_in_l
    name: "ERV input low"
  - platform: speed
    output: erv_out_l
    name: "ERV output low"

output:
  - platform: ledc
    pin: $erv_in_l_pin
    id: erv_in_l
    frequency: 19531Hz
  - platform: ledc
    pin: $erv_out_l_pin
    id: erv_out_l
    frequency: 19531Hz
