substitutions:
  device_name: garage-controls
  # device_name: dc-circuit-breaker
  eth_cs: GPIO9
  eth_clk: GPIO10
  eth_miso: GPIO11
  eth_mosi: GPIO12
  eth_int: GPIO13
  eth_rst: GPIO14

  scl: GPIO4
  sda: GPIO5
  scl2: GPIO6
  sda2: GPIO7

  motor_speed: 75%
  motor_speed_pin: GPIO17
  motor_dir_A: GPIO16
  motor_dir_B: GPIO15

  lock_r_lock: GPIO18
  lock_r_unlock: GPIO8

  man_door_lock_pin: GPIO19

external_components:
  - source:
      type: local
      path: ../../my_components # path relative to Devices folder

esphome:
  name: $device_name
  platformio_options:
    board_build.flash_mode: dio
  on_boot:
    - priority: -100
      then:
        - lock.lock: man_door_lock


esp32:
  board: esp32-s3-devkitc-1
  variant: esp32s3
  flash_size: 8MB
  framework:
    type: esp-idf
    sdkconfig_options:
      CONFIG_ESPTOOLPY_FLASHSIZE_8MB: y
      # CONFIG_ESP_TIMER_SUPPORTS_ISR_DISPATCH_METHOD: y

preferences:
  # the default of 1min is far too short--flash chip is rated for approx 100k writes.
  flash_write_interval: "240h"

api:
  # password: ""
ota:
  platform: esphome
  password: ""

logger:
  level: debug
  logs:
    wifi: INFO
    sensor: INFO
    binary_sensor: INFO
    lock: debug


ethernet:
  type: W5500
  clk_pin: $eth_clk
  mosi_pin: $eth_mosi
  miso_pin: $eth_miso
  cs_pin: $eth_cs
  interrupt_pin: $eth_int
  reset_pin: $eth_rst
  use_address: "$device_name.local"


time:
  - platform: homeassistant

button:
  - platform: restart
    name: "$device_name Restart"

text_sensor:
  - platform: version
    name: "$device_name Version"

i2c:
  - id: bus_b
    sda: $sda
    scl: $scl
    scan: true
    frequency: 10kHz
  - id: bus_a
    sda: $sda2
    scl: $scl2
    scan: true
    frequency: 10kHz


.defaultfilters:
  - &moving_avg
    sliding_window_moving_average:
      window_size: 30
      send_every: 30

sensor:
  - { platform: uptime, id: uptime_seconds, update_interval: 1min }
  - { platform: template, id: uptime_days, name: "$device_name uptime", update_interval: 1min, device_class: duration, entity_category: "diagnostic", unit_of_measurement: "d",
      accuracy_decimals: 2, lambda: !lambda "return id(uptime_seconds).state / 86'400;", }
  - platform: sht4x
    update_interval: 1s
    i2c_id: bus_a
    temperature:
      name: "ERV Intake Temperature"
      id: erv_in_temp
      unit_of_measurement: "°C"
      filters: [ *moving_avg ]
    humidity:
      name: "ERV Intake Humidity"
      id: erv_in_humid
      filters: [ *moving_avg ]
  - platform: sht4x
    update_interval: 1s
    i2c_id: bus_b
    temperature:
      name: "Garage Attic Temperature"
      id: garage_attic_temp
      unit_of_measurement: "°C"
      filters: [ *moving_avg ]
    humidity:
      name: "Garage Attic Humidity"
      id: garage_attic_humid
      filters: [ *moving_avg ]


output:
  - platform: ledc
    pin: $motor_speed_pin
    id: motor_speed_output
    frequency: 19531Hz
    # 39063Hz
  - platform: gpio
    pin: $motor_dir_B
    id: motor_dir_1
  - platform: gpio
    pin: $motor_dir_A
    id: motor_dir_2
  - platform: ledc
    pin: $man_door_lock_pin
    id: man_door_lock_output
    frequency: 19531Hz

globals:
  - { id: lock_r_moving, type: bool, initial_value: "false" }
  - { id: lock_r_target, type: LockState, initial_value: "LOCK_STATE_NONE" }

script:
  - id: check_lock_jammed
    mode: restart
    then:
      - delay: 5s
      - output.turn_off: motor_speed_output
      - globals.set: { id: lock_r_moving, value: "false"}
      - script.execute: { id: eval_lock_state, is_right_door: true} 
  - id: auto_lock_man_door
    mode: restart
    then:
      - delay: 5s
      - lock.lock: man_door_lock
  - id: eval_lock_state
    mode: single
    parameters:
      is_right_door: bool
    then:
      - lambda: |
          auto lock = id(door_r_lock);
          auto target = id(lock_r_target);
          auto is_moving = &id(lock_r_moving);
          auto lock_sensor = id(r_lock_sensor);
          auto unlock_sensor = id(r_unlock_sensor);
          if(!is_right_door){

          }
          ESP_LOGI("LockEval", "%s: unlocked: %d, locked: %d, is_moving: %d, target: %d",
            is_right_door ? "right" : "left", unlock_sensor->state, lock_sensor->state, id(lock_r_moving), target);
          
          if (unlock_sensor->state && lock_sensor->state) {
              // Both sensors are active, should not happen
              lock->publish_state(LOCK_STATE_JAMMED);
          } else if (unlock_sensor->state ) {
              // Unlock sensor is active
              id(motor_speed_output).turn_off();
              id(check_lock_jammed).stop();
              if(*is_moving){
                if(target == LOCK_STATE_UNLOCKING || target == LOCK_STATE_UNLOCKED ){
                  lock->publish_state(LOCK_STATE_UNLOCKED);
                }else{
                  lock->publish_state(LOCK_STATE_JAMMED);
                }
              }else{
                lock->publish_state(LOCK_STATE_UNLOCKED);
              }
              *is_moving = false;
          } else if (lock_sensor->state) {
              // Lock sensor is active
              id(motor_speed_output).turn_off();
              id(check_lock_jammed).stop();
              if(*is_moving){
                if(target == LOCK_STATE_LOCKING || target == LOCK_STATE_LOCKED ){
                  lock->publish_state(LOCK_STATE_LOCKED);
                }else{
                 lock->publish_state(LOCK_STATE_JAMMED);
                }
              }else{
                lock->publish_state(LOCK_STATE_LOCKED);
              }
              *is_moving = false;
          } else { 
              // Neither sensor is active
              if (*is_moving) {
                if(target == LOCK_STATE_LOCKING ){
                  // lock is moving to the locked position
                  lock->publish_state(LOCK_STATE_LOCKING);
                  target = LOCK_STATE_LOCKED;
                }
                if(target == LOCK_STATE_UNLOCKING){
                  // lock is moving to the unlocked position
                  lock->publish_state(LOCK_STATE_UNLOCKING);
                  target = LOCK_STATE_UNLOCKED;
                }
              } else {
                // lock was not commanded to move but is being moved manually
                lock->publish_state(LOCK_STATE_JAMMED);
              }
          }

# track when the lock was commanded to move vs when it was move externally through lock_r_moving
# track the target state to determine if it reached the target or is jammed
lock:
  - platform: template
    id: door_r_lock
    name: "Right Garage Door Lock"
    lock_action:
      - globals.set: { id: lock_r_moving, value: "true"}
      - globals.set: { id: lock_r_target, value: "LOCK_STATE_LOCKING"}
      - output.turn_off: motor_dir_1
      - output.turn_on: motor_dir_2
      - output.set_level: { id: motor_speed_output, level: $motor_speed }
      - script.execute: check_lock_jammed
    unlock_action:
      - globals.set: { id: lock_r_moving, value: "true"}
      - globals.set: { id: lock_r_target, value: "LOCK_STATE_UNLOCKING"}
      - output.turn_on: motor_dir_1
      - output.turn_off: motor_dir_2
      - output.set_level: { id: motor_speed_output, level: $motor_speed }
      - script.execute: check_lock_jammed
    open_action:
      - globals.set: { id: lock_r_moving, value: "true"}
      - globals.set: { id: lock_r_target, value: "LOCK_STATE_UNLOCKING"}
      - output.turn_on: motor_dir_1
      - output.turn_off: motor_dir_2
      - output.set_level: { id: motor_speed_output, level: $motor_speed }
      - script.execute: check_lock_jammed
  - platform: template
    id: man_door_lock
    name: "Garage Man Door Lock"
    optimistic: true
    lock_action:
      - output.turn_off: man_door_lock_output
    unlock_action:
      - output.set_level: { id: man_door_lock_output, level: 75% }
      - script.execute: auto_lock_man_door
    open_action:
      - output.set_level: { id: man_door_lock_output, level: 75% }
      - script.execute: auto_lock_man_door



#   valid options are 'LOCKED', 'UNLOCKED', 'JAMMED', 'LOCKING', 'UNLOCKING'

binary_sensor:
  - platform: status
    id: connection_status
    on_state:
      then:
        - delay: 3s
        - lock.lock: man_door_lock
        - if:
            condition: { binary_sensor.is_on: r_lock_sensor }
            then:
              - lock.template.publish: { id: door_r_lock, state: LOCKED }
              - globals.set: { id: lock_r_moving, value: "false"}
            else:
              - if:
                  condition: { binary_sensor.is_on: r_unlock_sensor }
                  then:
                    - lock.template.publish: { id: door_r_lock, state: UNLOCKED }
                    - globals.set: { id: lock_r_moving, value: "false"}
                  else: { lock.lock: door_r_lock }
  - platform: gpio
    id: r_lock_sensor
    pin: { number: $lock_r_lock, mode: { input: true, pulldown : true } }
    filters: [ delayed_on_off: 100ms]
    on_state: 
      then:
        - script.execute: { id: eval_lock_state, is_right_door: true} 
  - platform: gpio
    id: r_unlock_sensor
    pin: { number: $lock_r_unlock, mode: { input: true, pulldown : true } }
    filters: [ delayed_on_off: 100ms]
    on_state: 
      then:
        - script.execute: { id: eval_lock_state, is_right_door: true} 

